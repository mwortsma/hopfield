<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <style>
        body {font-family: monospace; line-height: 160%; font-size: 18px; }
        ul {list-style: none; margin: 0; padding: 0;}
        li {display: inline-block; min-width: 80px; padding: 10px; background-color: #eee; margin: 0;}
        input {border: 1px dotted #ccc; background: white; font-family: monospace; padding: 10px 20px; font-size: 18px; margin: 20px 10px 20px 0; color: red;}
        input:focus { background-color:yellow; outline: none;}
    </style>
</head>

<body>

<form name="myform" onSubmit="return handleClick()">
    <input name="Submit"  type="submit" value="1. Add binary vector to remember (add as many as you like)." >
    <input type="text" id="myVal" placeholder="Enter e.g. 11101101">
</form>


<div id="option">
    <input name="run" 
           type="button" 
           value="2. Initialize Neurons (first press this button, then click them for value = 1)." 
           onclick="init()" />
</div>

<div id="option">
    <input name="run" 
           type="button" 
           value="3. Run Hopfield Network." 
           onclick="run()" />
</div>

<ul></ul>



<!-- load the d3.js library -->    
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>

var dataset = [];


function handleClick(event){
    var binaryStr = document.getElementById("myVal").value;
    if(binaryStr.length < 2){
        alert('Vectors must be > 1 dimensional.');
        return false;
    }

    for (var i = 0, len = binaryStr.length; i < len; i++) {
        if( binaryStr[i] != '1' && binaryStr[i] != 0 ){
            alert('Must enter a binary string.');
            return false;
        }
    }

    draw(binaryStr);
    return false;
}

function draw(val){
    d3.select("body").select("ul").append("li");
    dataset.push(val);
    var p = d3.select("body").selectAll("li")
    .data(dataset)
    .text(function(d,i){return i + ": " + d;})
}

var n = 4;

var V = [1, 0, 1, 0];
var E = [ [1, 2, 3, 4], [4, 5, 6, 8], [7, 8, 9, 10], [4, 5, 6, 8] ];



function getRow(i){
    return Math.floor(i/n);
}

function getCol(i) {
    return i % n;
}

function getX(i) {
    return 200 - 140*Math.cos(2*Math.PI*i/n);
}

function getY(i) {
    console.log
    return 200 - 140*Math.sin(2*Math.PI*i/n);
}

var w = 500;
var h = 400;
var animationDuration = 300;

var running = false;


var svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h);


function drawNodes(data) {

    // DATA JOIN
    // Join new data with old elements, if any.
    var nodes = svg.selectAll("circle")
                 .data(data);

    // UPDATE
    // Update old elements as needed.
    nodes.attr("class", "update");

    function stateToColor(n) { 
        if(n == 1) { return "white"; } 
        else { return "black"; }
    }

    // ENTER
    // Create new elements as needed.
    //
    // ENTER + UPDATE
    // After merging the entered elements with the update selection,
    // apply operations to both.
    nodes.enter()
     .append("circle")
         .attr("class", "enter")
     .merge(nodes)
         .transition()
         .duration(animationDuration)
         .style("stroke", "gray")
         .style("fill", function(d) { return stateToColor(d.state); })
         .attr("cx", function(d, i) { return getX(i); })
         .attr("cy", function(d, i) { return getY(i); })
         .attr("r", 10);

    // EXIT
    // Remove old elements as needed.
    nodes.exit().remove();
}


function drawEdges(data) {

    // DATA JOIN
    // Join new data with old elements, if any.
    var edges = svg.selectAll("g")
                 .data(data)

    // UPDATE
    // Update old elements as needed.
    edges.attr("class", "update");

    // ENTER
    // Create new elements as needed.
    //
    // ENTER + UPDATE
    // After merging the entered elements with the update selection,
    // apply operations to both.
    edges.enter()
     .append("line")
         .attr("class", "enter")
         .style("stroke", "grey")
     .merge(edges)
         .attr("x1", function(d, i) { return getX(getRow(i)); })
         .attr("x2", function(d, i) { return getX(getCol(i)); })
         .attr("y1", function(d, i) { return getY(getRow(i)); })
         .attr("y2", function(d, i) { return getY(getCol(i)); })

    // EXIT
    // Remove old elements as needed.
    edges.exit().remove();
}


function update() {
    drawNodes(V);
    drawEdges([].concat.apply([], E));
}

var initialized = false;

function init() {
    if(dataset.length == 0){
        alert("Must complete step 1 first.");
        return false;
    }

    update();

    svg.selectAll("text")
        .data(V)
        .enter()
        .append("text")
        .text(function(d, i) { return i; })
        .attr("x", function(d, i) { return getX(i) + 15; })
        .attr("y", function(d, i) { return getY(i) - 15; });

    initialized = true;
}


function run() {
    if(dataset.length == 0 || !initialized){
        alert("Must complete step 1 and 2 first.");
        return false;
    }
    if(running){ return; }
    d3.interval(function() {
      E[0][0] = 1 - E[0][0];
      V[0].state = 1 - V[0].state;
      update();
    }, 1500);
    running = true;
}



</script>
</body>
